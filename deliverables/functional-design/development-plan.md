# Development Plan

## Timeline

The following table covers the main features of our application, the team member responsible for them, and the due date for a **working version** of the feature itself. By the due date, the feature should be completely functional and near its final state, but tweaks can still be made after the due date in order to polish the project to the best of our capabilities.

| Feature                             | Team Member | Due Date |
| ----------------------------------- | ----------- | -------- |
| User Profile                        | Kayle       | Nov 20   |
| Item Listings                       | Sebastian   | Nov 22   |
| Item Requests                       | Anthony     | Nov 22   |
| Search, filtering, and Enhancements | Kayle       | Nov 24   |
| Checkpoint 1                        | All         | Nov 25   |
| Incentives                          | Sebastian   | Nov 27   |
| Communication                       | Anthony     | Nov 29   |
| Notifications                       | Kayle       | Nov 30   |
| Reputation System                   | Sebastian   | Nov 30   |
| Checkpoint 2                        | All         | Dec 2    |
| Final Review                        | All         | Dec 5    |

## Key Risks and Fallback

The key risks we face primarily deal with our time constraints. Compared to our personal projects, the timeline for this is very tight, so we need to be agile and efficient with how we work. As such, we have created an explicit timeline for the completion date of the features, which will allow for a structured workflow and give us the opportunity to keep each other accountable. We seek to mitigate this concern by being in constant communication with each other, and working in a timely manner such that no one falls behind on their assigned work. 

Another concern is complexity. Although we have created concept specs for every part of our application, complexity during implementation is hard to gauge. In order to make sure that we do not get wrapped up or stuck in the complexity of a concept, we seek to strike a balance of functionality and complexity. We want to make our features as complete as possible, but there needs to be a point where we are satisfied with the performance and do not try to reach for something that may not be worth the time for effort in exchange for the results it may provide.

If any of our desired features turn out to be unimplementable, then our first fallback plan is to attempt to scale it down. We want our user experience to be as robust and as complete as possible, so functionality is not something we want to skimp on. Therefore, we will always try to scale down unattainable features first in order to try to retain the functionality in the application. However, if this is not possible, then the most sensible option is to scrap the feature all together, and try to fill in the gap by implementing a new, more feasible, feature or enhance the other features that are already present.