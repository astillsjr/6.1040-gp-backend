---
timestamp: 'Mon Nov 24 2025 02:23:24 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251124_022324.365f8cd0.md]]'
content_id: 5087e286ad75196e81cbf0caf0b95a09ce78f261c3bef26a9d29e2a2f9e6f106
---

# Synchronizations

## UserRegistrationFlow

**sync**: UserRegistrationFlow\
**when**: UserAuthentication.register (user: User)\
**then**: Rewards.initializeRewards (user: User), Reputation.initializeReputation (user: User)\
**notes**: When a user registers, we automatically create their rewards account and reputation record. Profile creation is handled separately when the user provides their display name and dorm information, as these are not available at registration time.

***

## ItemAvailabilityReservation

**sync**: ItemAvailabilityReservation\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, requestedStartTime of request is startTime, requestedEndTime of request is endTime\
**then**: ItemListing.markUnavailable (item: Item, window: AvailabilityWindow)\
**notes**: When a borrow request is approved, we need to mark the corresponding availability window as RESERVED/UNAVAILABLE to prevent double-booking. The sync needs to find the matching availability window based on the time range. **ISSUE**: Need to determine how to identify the specific AvailabilityWindow to mark unavailable - may need a query or additional state.

***

## ItemAvailabilityRelease

**sync**: ItemAvailabilityRelease\
**when**: Borrowing.completeRequest (request: BorrowRequest), Borrowing.cancelRequest (request: BorrowRequest), Borrowing.rejectRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item\
**then**: ItemListing.setAvailability (item: Item, startTime: DateTime, endTime: DateTime)\
**notes**: When a request is completed, cancelled, or rejected, we should release the availability window back to available status. However, this requires knowing the original window times, which may need to be stored in the BorrowRequest or queried. **ISSUE**: Need to track which availability window was reserved for a request.

***

## LendingRewardAward

**sync**: LendingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Rewards.awardPoints (user: lender, amount: Number, reason: String)\
**notes**: Lenders earn points when a borrowing transaction completes successfully. The amount could be fixed or based on item value/duration. **ISSUE**: Need to determine point calculation formula - fixed amount vs. variable based on item characteristics.

***

## BorrowingRewardAward

**sync**: BorrowingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Rewards.awardPoints (user: borrower, amount: Number, reason: String)\
**notes**: Borrowers also earn points for completing transactions responsibly, incentivizing good behavior. The amount for borrowers is typically less than for lenders. **ISSUE**: Same as LendingRewardAward - need point calculation formula.

***

## ReputationUpdateOnReview

**sync**: ReputationUpdateOnReview\
**when**: Reputation.submitReview (review: Review)\
**where**: in Reputation: reviewee of review is user\
**then**: Reputation.updateScores (user: User)\
**notes**: When a new review is submitted, we automatically recalculate the reviewee's reputation scores. This ensures scores are always up-to-date.

***

## ConversationCreationOnRequest

**sync**: ConversationCreationOnRequest\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Communication.createConversation (participant1: borrower, participant2: lender, context: request, contextType: "BORROW\_REQUEST")\
**notes**: Automatically create a conversation when a borrow request is made, enabling immediate communication between parties.

***

## NewRequestNotification

**sync**: NewRequestNotification\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: lender, type: "NEW\_REQUEST", title: String, content: String)\
**notes**: Notify the lender when they receive a new borrow request. The title and content can be constructed from the request details.

***

## RequestApprovedNotification

**sync**: RequestApprovedNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Notifications.createNotification (recipient: borrower, type: "REQUEST\_APPROVED", title: String, content: String)\
**notes**: Notify the borrower when their request is approved.

***

## PickupReminderNotification

**sync**: PickupReminderNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: requestedStartTime of request is startTime\
**then**: Notifications.createNotification (recipient: borrower, type: "PICKUP\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for pickup. The actual sending should be scheduled for some time before the pickup (e.g., 1 hour before). **ISSUE**: Need a scheduling mechanism for time-based notifications - may require a system action that runs periodically.

***

## ReturnReminderNotification

**sync**: ReturnReminderNotification\
**when**: Borrowing.markPickedUp (request: BorrowRequest)\
**where**: in Borrowing: requestedEndTime of request is endTime\
**then**: Notifications.createNotification (recipient: borrower, type: "RETURN\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for return when an item is picked up. Similar scheduling issue as PickupReminderNotification.

***

## MessageNotification

**sync**: MessageNotification\
**when**: Communication.sendMessage (message: Message)\
**where**: in Communication: conversation of message is conversation, sender of message is sender, in Communication: participant1 of conversation is recipient or participant2 of conversation is recipient, recipient is not sender\
**then**: Notifications.createNotification (recipient: recipient, type: "NEW\_MESSAGE", title: String, content: String)\
**notes**: Notify the recipient when they receive a new message. The sync identifies the recipient as the other participant in the conversation.

***

## NotificationDelivery

**sync**: NotificationDelivery\
**when**: Notifications.createNotification (notification: Notification)\
**where**: in Notifications: status of notification is PENDING\
**then**: Notifications.sendNotification (notification: Notification)\
**notes**: Automatically trigger notification delivery when a notification is created. For time-based reminders, this sync might be conditional or the sendNotification action might check timing internally.

***

## ReviewReminderNotification

**sync**: ReviewReminderNotification\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: borrower, type: "REVIEW\_REMINDER", title: String, content: String), Notifications.createNotification (recipient: lender, type: "REVIEW\_REMINDER", title: String, content: String)\
**notes**: Remind both parties to leave reviews after a transaction completes. This encourages review submission and helps build the reputation system.

***

## ItemRequestCreatedNotification

**sync**: ItemRequestCreatedNotification\
**when**: ItemRequest.createRequest (request: ItemRequest)\
**where**: in ItemRequest: dormVisibility of request is dormVisibility, requester of request is requester\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_ITEM\_REQUEST", title: String, content: String)\
**notes**: Notify relevant users (based on dorm visibility) when a new item request is created in their area. This helps surface requests to potential contributors. **ISSUE**: Need to determine how to identify all users in a specific dorm for dorm-specific notifications - may require querying UserProfile concept state.

***

## ContributionOfferedNotification

**sync**: ContributionOfferedNotification\
**when**: ItemRequest.offerContribution (contribution: Contribution)\
**where**: in ItemRequest: request of contribution is request, requester of request is requester\
**then**: Notifications.createNotification (recipient: requester, type: "CONTRIBUTION\_OFFERED", title: String, content: String)\
**notes**: Notify the requester when someone offers a contribution to their request.

***

## ContributionAcceptedNotification

**sync**: ContributionAcceptedNotification\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: contributor of contribution is contributor\
**then**: Notifications.createNotification (recipient: contributor, type: "CONTRIBUTION\_ACCEPTED", title: String, content: String)\
**notes**: Notify the contributor when their contribution is accepted.

***

## ItemRequestFulfilledNotification

**sync**: ItemRequestFulfilledNotification\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: request of contribution is request, status of request is FULFILLED, requester of request is requester\
**then**: Notifications.createNotification (recipient: requester, type: "REQUEST\_FULFILLED", title: String, content: String)\
**notes**: Notify the requester when their request is fully fulfilled. This sync fires when accepting a contribution that completes the request.

***

## ItemRequestContributionReward

**sync**: ItemRequestContributionReward\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: contributor of contribution is contributor\
**then**: Rewards.awardPoints (user: contributor, amount: Number, reason: String)\
**notes**: Award points to users who contribute items to fulfill requests, incentivizing community sourcing. **ISSUE**: Need to determine point calculation - could be based on quantity or fixed amount per contribution.

***

## FreeItemPostedNotification

**sync**: FreeItemPostedNotification\
**when**: ItemTransfer.postFreeItem (item: Item), ItemTransfer.postUpcycleItem (item: Item)\
**where**: in ItemTransfer: dormVisibility of item is dormVisibility\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_FREE\_ITEM", title: String, content: String)\
**notes**: Notify relevant users (based on dorm visibility) when a new free or upcycle item is posted. This helps surface available items. **ISSUE**: Same dorm visibility notification issue as ItemRequestCreatedNotification.

***

## LostItemPostedNotification

**sync**: LostItemPostedNotification\
**when**: ItemTransfer.postLostItem (item: Item)\
**where**: in ItemTransfer: dormVisibility of item is dormVisibility\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_LOST\_ITEM", title: String, content: String)\
**notes**: Notify relevant users when a lost item is posted, helping reunite items with their owners. **ISSUE**: Same dorm visibility notification issue.

***

## ItemClaimedNotification

**sync**: ItemClaimedNotification\
**when**: ItemTransfer.claimItem (claim: Claim)\
**where**: in ItemTransfer: item of claim is item, postedBy of item is postedBy\
**then**: Notifications.createNotification (recipient: postedBy, type: "ITEM\_CLAIMED", title: String, content: String)\
**notes**: Notify the item poster when someone claims their free/lost/upcycle item.

***

## ItemClaimApprovedNotification

**sync**: ItemClaimApprovedNotification\
**when**: ItemTransfer.approveClaim (claim: Claim)\
**where**: in ItemTransfer: claimer of claim is claimer\
**then**: Notifications.createNotification (recipient: claimer, type: "CLAIM\_APPROVED", title: String, content: String)\
**notes**: Notify the claimer when their claim is approved.

***

## FreeItemPostingReward

**sync**: FreeItemPostingReward\
**when**: ItemTransfer.completeTransfer (item: Item, claim: Claim)\
**where**: in ItemTransfer: transferType of item is FREE or UPCYCLE, postedBy of item is postedBy\
**then**: Rewards.awardPoints (user: postedBy, amount: Number, reason: String)\
**notes**: Award points to users who successfully complete free item or upcycle transfers, incentivizing waste reduction. **ISSUE**: Need to determine point calculation for free item postings.

***

## ItemTransferConversation

**sync**: ItemTransferConversation\
**when**: ItemTransfer.claimItem (claim: Claim)\
**where**: in ItemTransfer: item of claim is item, claimer of claim is claimer, postedBy of item is postedBy\
**then**: Communication.createConversation (participant1: claimer, participant2: postedBy, context: claim, contextType: "ITEM\_CLAIM")\
**notes**: Create a conversation when an item is claimed to enable coordination between the claimer and the item poster.
