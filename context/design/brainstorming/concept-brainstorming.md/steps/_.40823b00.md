---
timestamp: 'Sun Nov 23 2025 23:26:35 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251123_232635.6a77566c.md]]'
content_id: 40823b005193e1f45ab11fcb961d790edac5753e338c5cbb381faa732225f5b4
---

# Synchronizations

## UserRegistrationFlow

**sync**: UserRegistrationFlow\
**when**: UserAuthentication.register (user: User)\
**then**: Rewards.initializeRewards (user: User), Reputation.initializeReputation (user: User)\
**notes**: When a user registers, we automatically create their rewards account and reputation record. Profile creation is handled separately when the user provides their display name and dorm information, as these are not available at registration time.

***

## ItemAvailabilityReservation

**sync**: ItemAvailabilityReservation\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, requestedStartTime of request is startTime, requestedEndTime of request is endTime\
**then**: ItemListing.markUnavailable (item: Item, window: AvailabilityWindow)\
**notes**: When a borrow request is approved, we need to mark the corresponding availability window as RESERVED/UNAVAILABLE to prevent double-booking. The sync needs to find the matching availability window based on the time range. **ISSUE**: Need to determine how to identify the specific AvailabilityWindow to mark unavailable - may need a query or additional state.

***

## ItemAvailabilityRelease

**sync**: ItemAvailabilityRelease\
**when**: Borrowing.completeRequest (request: BorrowRequest), Borrowing.cancelRequest (request: BorrowRequest), Borrowing.rejectRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item\
**then**: ItemListing.setAvailability (item: Item, startTime: DateTime, endTime: DateTime)\
**notes**: When a request is completed, cancelled, or rejected, we should release the availability window back to available status. However, this requires knowing the original window times, which may need to be stored in the BorrowRequest or queried. **ISSUE**: Need to track which availability window was reserved for a request.

***

## LendingRewardAward

**sync**: LendingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Rewards.awardPoints (user: lender, amount: Number, reason: String)\
**notes**: Lenders earn points when a borrowing transaction completes successfully. The amount could be fixed or based on item value/duration. **ISSUE**: Need to determine point calculation formula - fixed amount vs. variable based on item characteristics.

***

## BorrowingRewardAward

**sync**: BorrowingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Rewards.awardPoints (user: borrower, amount: Number, reason: String)\
**notes**: Borrowers also earn points for completing transactions responsibly, incentivizing good behavior. The amount for borrowers is typically less than for lenders. **ISSUE**: Same as LendingRewardAward - need point calculation formula.

***

## ReputationUpdateOnReview

**sync**: ReputationUpdateOnReview\
**when**: Reputation.submitReview (review: Review)\
**where**: in Reputation: reviewee of review is user\
**then**: Reputation.updateScores (user: User)\
**notes**: When a new review is submitted, we automatically recalculate the reviewee's reputation scores. This ensures scores are always up-to-date.

***

## ConversationCreationOnRequest

**sync**: ConversationCreationOnRequest\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Communication.createConversation (participant1: borrower, participant2: lender, context: request, contextType: "BORROW\_REQUEST")\
**notes**: Automatically create a conversation when a borrow request is made, enabling immediate communication between parties.

***

## NewRequestNotification

**sync**: NewRequestNotification\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: lender, type: "NEW\_REQUEST", title: String, content: String)\
**notes**: Notify the lender when they receive a new borrow request. The title and content can be constructed from the request details.

***

## RequestApprovedNotification

**sync**: RequestApprovedNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Notifications.createNotification (recipient: borrower, type: "REQUEST\_APPROVED", title: String, content: String)\
**notes**: Notify the borrower when their request is approved.

***

## PickupReminderNotification

**sync**: PickupReminderNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: requestedStartTime of request is startTime\
**then**: Notifications.createNotification (recipient: borrower, type: "PICKUP\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for pickup. The actual sending should be scheduled for some time before the pickup (e.g., 1 hour before). **ISSUE**: Need a scheduling mechanism for time-based notifications - may require a system action that runs periodically.

***

## ReturnReminderNotification

**sync**: ReturnReminderNotification\
**when**: Borrowing.markPickedUp (request: BorrowRequest)\
**where**: in Borrowing: requestedEndTime of request is endTime\
**then**: Notifications.createNotification (recipient: borrower, type: "RETURN\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for return when an item is picked up. Similar scheduling issue as PickupReminderNotification.

***

## MessageNotification

**sync**: MessageNotification\
**when**: Communication.sendMessage (message: Message)\
**where**: in Communication: conversation of message is conversation, sender of message is sender, in Communication: participant1 of conversation is recipient or participant2 of conversation is recipient, recipient is not sender\
**then**: Notifications.createNotification (recipient: recipient, type: "NEW\_MESSAGE", title: String, content: String)\
**notes**: Notify the recipient when they receive a new message. The sync identifies the recipient as the other participant in the conversation.

***

## NotificationDelivery

**sync**: NotificationDelivery\
**when**: Notifications.createNotification (notification: Notification)\
**where**: in Notifications: status of notification is PENDING\
**then**: Notifications.sendNotification (notification: Notification)\
**notes**: Automatically trigger notification delivery when a notification is created. For time-based reminders, this sync might be conditional or the sendNotification action might check timing internally.

***

## ReviewReminderNotification

**sync**: ReviewReminderNotification\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: borrower, type: "REVIEW\_REMINDER", title: String, content: String), Notifications.createNotification (recipient: lender, type: "REVIEW\_REMINDER", title: String, content: String)\
**notes**: Remind both parties to leave reviews after a transaction completes. This encourages review submission and helps build the reputation system.

***

## ItemRequestCreatedNotification

**sync**: ItemRequestCreatedNotification\
**when**: ItemRequest.createRequest (request: ItemRequest)\
**where**: in ItemRequest: dormVisibility of request is dormVisibility, requester of request is requester\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_ITEM\_REQUEST", title: String, content: String)\
**notes**: Notify relevant users (based on dorm visibility) when a new item request is created in their area. This helps surface requests to potential contributors. **ISSUE**: Need to determine how to identify all users in a specific dorm for dorm-specific notifications - may require querying UserProfile concept state.

***

## ContributionOfferedNotification

**sync**: ContributionOfferedNotification\
**when**: ItemRequest.offerContribution (contribution: Contribution)\
**where**: in ItemRequest: request of contribution is request, requester of request is requester\
**then**: Notifications.createNotification (recipient: requester, type: "CONTRIBUTION\_OFFERED", title: String, content: String)\
**notes**: Notify the requester when someone offers a contribution to their request.

***

## ContributionAcceptedNotification

**sync**: ContributionAcceptedNotification\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: contributor of contribution is contributor\
**then**: Notifications.createNotification (recipient: contributor, type: "CONTRIBUTION\_ACCEPTED", title: String, content: String)\
**notes**: Notify the contributor when their contribution is accepted.

***

## ItemRequestFulfilledNotification

**sync**: ItemRequestFulfilledNotification\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: request of contribution is request, status of request is FULFILLED, requester of request is requester\
**then**: Notifications.createNotification (recipient: requester, type: "REQUEST\_FULFILLED", title: String, content: String)\
**notes**: Notify the requester when their request is fully fulfilled. This sync fires when accepting a contribution that completes the request.

***

## ItemRequestContributionReward

**sync**: ItemRequestContributionReward\
**when**: ItemRequest.acceptContribution (contribution: Contribution)\
**where**: in ItemRequest: contributor of contribution is contributor\
**then**: Rewards.awardPoints (user: contributor, amount: Number, reason: String)\
**notes**: Award points to users who contribute items to fulfill requests, incentivizing community sourcing. **ISSUE**: Need to determine point calculation - could be based on quantity or fixed amount per contribution.

***

## FreeItemPostedNotification

**sync**: FreeItemPostedNotification\
**when**: ItemTransfer.postFreeItem (item: Item), ItemTransfer.postUpcycleItem (item: Item)\
**where**: in ItemTransfer: dormVisibility of item is dormVisibility\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_FREE\_ITEM", title: String, content: String)\
**notes**: Notify relevant users (based on dorm visibility) when a new free or upcycle item is posted. This helps surface available items. **ISSUE**: Same dorm visibility notification issue as ItemRequestCreatedNotification.

***

## LostItemPostedNotification

**sync**: LostItemPostedNotification\
**when**: ItemTransfer.postLostItem (item: Item)\
**where**: in ItemTransfer: dormVisibility of item is dormVisibility\
**then**: Notifications.createNotification (recipient: User, type: "NEW\_LOST\_ITEM", title: String, content: String)\
**notes**: Notify relevant users when a lost item is posted, helping reunite items with their owners. **ISSUE**: Same dorm visibility notification issue.

***

## ItemClaimedNotification

**sync**: ItemClaimedNotification\
**when**: ItemTransfer.claimItem (claim: Claim)\
**where**: in ItemTransfer: item of claim is item, postedBy of item is postedBy\
**then**: Notifications.createNotification (recipient: postedBy, type: "ITEM\_CLAIMED", title: String, content: String)\
**notes**: Notify the item poster when someone claims their free/lost/upcycle item.

***

## ItemClaimApprovedNotification

**sync**: ItemClaimApprovedNotification\
**when**: ItemTransfer.approveClaim (claim: Claim)\
**where**: in ItemTransfer: claimer of claim is claimer\
**then**: Notifications.createNotification (recipient: claimer, type: "CLAIM\_APPROVED", title: String, content: String)\
**notes**: Notify the claimer when their claim is approved.

***

## FreeItemPostingReward

**sync**: FreeItemPostingReward\
**when**: ItemTransfer.completeTransfer (item: Item, claim: Claim)\
**where**: in ItemTransfer: transferType of item is FREE or UPCYCLE, postedBy of item is postedBy\
**then**: Rewards.awardPoints (user: postedBy, amount: Number, reason: String)\
**notes**: Award points to users who successfully complete free item or upcycle transfers, incentivizing waste reduction. **ISSUE**: Need to determine point calculation for free item postings.

***

## ItemTransferConversation

**sync**: ItemTransferConversation\
**when**: ItemTransfer.claimItem (claim: Claim)\
**where**: in ItemTransfer: item of claim is item, claimer of claim is claimer, postedBy of item is postedBy\
**then**: Communication.createConversation (participant1: claimer, participant2: postedBy, context: claim, contextType: "ITEM\_CLAIM")\
**notes**: Create a conversation when an item is claimed to enable coordination between the claimer and the item poster.

I have taken some very loose notes on suggestions for how to refactor your concepts. Note that these are not super refined, so **please use your best judgement**. I also created some draft states for the concepts I suggested (FYI, I may have left out some trivial state). This should help you reduce the amount of things you need to implement by creating more modular and reusable concepts! Below are my comments, please let me know if you have further questions!

* Extract Item as its own standalone concept

* store dormVisibility in the ItemListing concept

* status (LISTED/UNLISTED) does not need to be stored, you can calculate it when needed by using findOne on ItemListing

* we set owner to be optional in the case that someone wants to make an item request 

* Expand ItemListing concept to include 

* a type (BORROW or TRANSFER)

* dormVisibility

* a status

* Remove ItemTransfer, ItemRequest, Borrowing and consolidate functionality into Requesting, ItemTransaction (see below)

* ItemTransfer is handled with an instance of Item but with no owner field (also marked as the ITEM type in Reqeusting and ItemTransaction)

* Create Requesting

* only need to store requester because we know the requestee from the Item owner

* store type (BORROW or TRANSFER or ITEM)

* requesterNotes

* Create ItemTransaction concept

* this helps store any transactions

* store type (BORROW or TRANSFER or ITEM)

* an ItemRequest

* item associated with transaction is stored, store 

* Split up Reputation into Reviewing and Flagging

* I would skip the Flagging concept for now, can implement later if needed

* We can use the reviews to calculate the user reputation scores when needed

* The totalLends and totalBorrows should be calculated using the Borrowing concept

* If you would like to store the scores, you can do so in the UserProfile concept!

* Combine the Transactions + Redemptions in the Rewarding concept

* I would skip out on the types of transactions/redemptions, seems unnecessary (?), it would be a lot more annoying to handle the expiring stuff than i feel is worth lol

**Item** // to be used in all other concepts that use Item

* a set of Items with:

* owner?

* title, description, category, description, condition, createdAt

**ItemListing**

* set of Items

* type: BORROW, TRANSFER

* dormVisibility

* status: AVAILABLE, PENDING, CLAIMED, EXPIRED

* set of ItemPhotos

* item, photoUrl, order number

* set of AvailabilityWindows 

* item, startTime, endTime, status

**ItemTransactions**

* set of ItemTransactions

* from, to

* item

* type: BORROW, TRANSFER, ITEM

* createdAt, approvedAt, etc.

* fromNotes, toNotes

**Requesting**

* set of Requests

* requester

* item

* we know who the owner is bc that is stored in the item

* in the case of ITEM request, item does not have an owner

* type: BORROW, TRANSFER, ITEM

* BORROW means “requester” is requesting to borrow the item

* TRANSFER means “requester” is requesting to transfer the item

* ITEM means “requester” is requesting item, item has no owner. NOTE: ITEM is a special case, so be aware of how you handle someone resolving this request with their own item

* description

* category

* createdAt

* NOTE we handle the approvedAt/returnedAt/etc + lender/borrower notes in the ItemTransaction concept

**Reviewing**

* set of Reviews with:

* reviewer

* reviewee

* rating

* comment

* type: Lender or Borrower // can remove this, you are storing the borrower/lender in the BorrowRequest

* transaction BorrowRequest

* createdAt

// we use the reviews to calculate the user reputation

// if you would like to store the scores, you can do so in the UserProfile concept!

// then update the scores in syncs

**Flagging** // I would skip this concept for now

* set of UserFlags:

* flagger, flagged

* reason

* status: PENDING, RESOLVED, DISMISSED

* createdAt

* resolvedAt

**Rewarding**

* set of Users with points

* a set of PointTransactions 

* user, amount (+ or -)

* description (reason or redemptionType)

* transaction? // store associated transaction???

* createdAt

**Notification**

**Communication**
