---
timestamp: 'Tue Nov 18 2025 18:32:50 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251118_183250.8255b428.md]]'
content_id: cbb1d644ff1eacc1149341cc1149d06f8a9b3fc9c9e890ffe3e73aa78720e11d
---

# Synchronizations

## UserRegistrationFlow

**sync**: UserRegistrationFlow\
**when**: UserAuthentication.register (user: User)\
**then**: Rewards.initializeRewards (user: User), Reputation.initializeReputation (user: User)\
**notes**: When a user registers, we automatically create their rewards account and reputation record. Profile creation is handled separately when the user provides their display name and dorm information, as these are not available at registration time.

***

## ItemAvailabilityReservation

**sync**: ItemAvailabilityReservation\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, requestedStartTime of request is startTime, requestedEndTime of request is endTime\
**then**: ItemListing.markUnavailable (item: Item, window: AvailabilityWindow)\
**notes**: When a borrow request is approved, we need to mark the corresponding availability window as RESERVED/UNAVAILABLE to prevent double-booking. The sync needs to find the matching availability window based on the time range. **ISSUE**: Need to determine how to identify the specific AvailabilityWindow to mark unavailable - may need a query or additional state.

***

## ItemAvailabilityRelease

**sync**: ItemAvailabilityRelease\
**when**: Borrowing.completeRequest (request: BorrowRequest), Borrowing.cancelRequest (request: BorrowRequest), Borrowing.rejectRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item\
**then**: ItemListing.setAvailability (item: Item, startTime: DateTime, endTime: DateTime)\
**notes**: When a request is completed, cancelled, or rejected, we should release the availability window back to available status. However, this requires knowing the original window times, which may need to be stored in the BorrowRequest or queried. **ISSUE**: Need to track which availability window was reserved for a request.

***

## LendingRewardAward

**sync**: LendingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Rewards.awardPoints (user: lender, amount: Number, reason: String)\
**notes**: Lenders earn points when a borrowing transaction completes successfully. The amount could be fixed or based on item value/duration. **ISSUE**: Need to determine point calculation formula - fixed amount vs. variable based on item characteristics.

***

## BorrowingRewardAward

**sync**: BorrowingRewardAward\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Rewards.awardPoints (user: borrower, amount: Number, reason: String)\
**notes**: Borrowers also earn points for completing transactions responsibly, incentivizing good behavior. The amount for borrowers is typically less than for lenders. **ISSUE**: Same as LendingRewardAward - need point calculation formula.

***

## ReputationUpdateOnReview

**sync**: ReputationUpdateOnReview\
**when**: Reputation.submitReview (review: Review)\
**where**: in Reputation: reviewee of review is user\
**then**: Reputation.updateScores (user: User)\
**notes**: When a new review is submitted, we automatically recalculate the reviewee's reputation scores. This ensures scores are always up-to-date.

***

## ConversationCreationOnRequest

**sync**: ConversationCreationOnRequest\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Communication.createConversation (participant1: borrower, participant2: lender, context: request)\
**notes**: Automatically create a conversation when a borrow request is made, enabling immediate communication between parties.

***

## NewRequestNotification

**sync**: NewRequestNotification\
**when**: Borrowing.requestBorrow (request: BorrowRequest)\
**where**: in Borrowing: item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: lender, type: "NEW\_REQUEST", title: String, content: String)\
**notes**: Notify the lender when they receive a new borrow request. The title and content can be constructed from the request details.

***

## RequestApprovedNotification

**sync**: RequestApprovedNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower\
**then**: Notifications.createNotification (recipient: borrower, type: "REQUEST\_APPROVED", title: String, content: String)\
**notes**: Notify the borrower when their request is approved.

***

## PickupReminderNotification

**sync**: PickupReminderNotification\
**when**: Borrowing.approveRequest (request: BorrowRequest)\
**where**: in Borrowing: requestedStartTime of request is startTime\
**then**: Notifications.createNotification (recipient: borrower, type: "PICKUP\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for pickup. The actual sending should be scheduled for some time before the pickup (e.g., 1 hour before). **ISSUE**: Need a scheduling mechanism for time-based notifications - may require a system action that runs periodically.

***

## ReturnReminderNotification

**sync**: ReturnReminderNotification\
**when**: Borrowing.markPickedUp (request: BorrowRequest)\
**where**: in Borrowing: requestedEndTime of request is endTime\
**then**: Notifications.createNotification (recipient: borrower, type: "RETURN\_REMINDER", title: String, content: String)\
**notes**: Create a reminder notification for return when an item is picked up. Similar scheduling issue as PickupReminderNotification.

***

## MessageNotification

**sync**: MessageNotification\
**when**: Communication.sendMessage (message: Message)\
**where**: in Communication: conversation of message is conversation, sender of message is sender, in Communication: participant1 of conversation is recipient or participant2 of conversation is recipient, recipient is not sender\
**then**: Notifications.createNotification (recipient: recipient, type: "NEW\_MESSAGE", title: String, content: String)\
**notes**: Notify the recipient when they receive a new message. The sync identifies the recipient as the other participant in the conversation.

***

## NotificationDelivery

**sync**: NotificationDelivery\
**when**: Notifications.createNotification (notification: Notification)\
**where**: in Notifications: status of notification is PENDING\
**then**: Notifications.sendNotification (notification: Notification)\
**notes**: Automatically trigger notification delivery when a notification is created. For time-based reminders, this sync might be conditional or the sendNotification action might check timing internally.

***

## ReviewReminderNotification

**sync**: ReviewReminderNotification\
**when**: Borrowing.completeRequest (request: BorrowRequest)\
**where**: in Borrowing: borrower of request is borrower, item of request is item, in ItemListing: owner of item is lender\
**then**: Notifications.createNotification (recipient: borrower, type: "REVIEW\_REMINDER", title: String, content: String), Notifications.createNotification (recipient: lender, type: "REVIEW\_REMINDER", title: String, content: String)\
**notes**: Remind both parties to leave reviews after a transaction completes. This encourages review submission and helps build the reputation system.
