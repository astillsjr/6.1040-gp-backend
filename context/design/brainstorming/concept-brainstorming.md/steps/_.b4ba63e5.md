---
timestamp: 'Sun Nov 23 2025 23:26:35 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251123_232635.6a77566c.md]]'
content_id: b4ba63e511938a7de8bbff4cfd66d77f1af29d80bd9ff4176fd0c8afab9efe6f
---

# Concept Specifications

## UserAuthentication

**concept**: UserAuthentication\
**purpose**: To authenticate users so that each person's data is securely associated with their identity and protected from unauthorized access.\
**principle**: If a user registers with a username and password, then later logs in using those same credentials, the system recognizes them as the same user, enabling access to their data. If they log out, their session ends and their private data becomes inaccessible until they log in again.\
**state**:

* a set of Users with
  * a username String
  * a hashedPassword String
  * an email String
  * a createdAt Date
* a set of Sessions with
  * a user User
  * a refreshToken String
  * a createdAt Date
  * an expiresAt Date

**actions**:

* `register (username: String, password: String, email: String): (user: User, accessToken: String, refreshToken: String)`
  * **requires**: The provided email and username must not already exist. The email must be in valid format.
  * **effects**: Creates a new user record with a hashed password and returns a new pair of session tokens.
* `login (username: String, password: String): (accessToken: String, refreshToken: String)`
  * **requires**: The provided username and password must match an existing user account.
  * **effects**: Creates a new session and returns a new pair of access and refresh tokens for the authenticated user.
* `logout (refreshToken: String)`
  * **requires**: A valid refresh token must be provided.
  * **effects**: Invalidates the user's current refresh token, ending their session.
* `changePassword (accessToken: String, oldPassword: String, newPassword: String)`
  * **requires**: A valid access token must be provided. The old password must match the user's current password.
  * **effects**: Updates the user's stored password hash to the new password.
* `deleteAccount (accessToken: String, password: String)`
  * **requires**: A valid access token must be provided. The provided password matches the user's current password.
  * **effects**: Permanently removes the user's account and all associated sessions.

**notes**:

* Sessions are stored separately from users to support multiple concurrent sessions per user and proper token management.
* Access tokens are not stored in state as they are stateless JWTs validated by signature. Only refresh tokens are stored for revocation purposes.
* Email is required for account recovery and notifications, though the notification delivery itself is handled by the Notifications concept.

***

## UserProfile

**concept**: UserProfile \[User]\
**purpose**: To maintain user profile information including display name, dorm affiliation, and other public-facing details that enable community connection and item discovery.\
**principle**: If a user creates a profile with their dorm and display name, then other users can find them by dorm and see their display name when viewing items they list or when communicating with them.\
**state**:

* a set of Users with
  * a displayName String
  * a dorm String
  * a bio String
  * a createdAt Date

**actions**:

* `createProfile (user: User, displayName: String, dorm: String): (profile: User)`
  * **requires**: The user must not already have a profile. The dorm must be a valid MIT dorm name.
  * **effects**: Creates a profile for the user with the provided display name and dorm.
* `updateProfile (user: User, displayName: String, dorm: String, bio: String)`
  * **requires**: The user must have an existing profile.
  * **effects**: Updates the user's profile information.
* `getProfile (user: User): (displayName: String, dorm: String, bio: String)`
  * **requires**: The user must have a profile.
  * **effects**: Returns the user's profile information.

**notes**:

* User is a generic type parameter since users are created by UserAuthentication. This concept only adds profile information to existing users.
* Dorm information is critical for the "dorm-specific visibility" feature and proximity-based recommendations.
* Display name is separate from username to allow users to present themselves differently in the community.

***

## ItemListing

**concept**: ItemListing \[User]\
**purpose**: To enable users to list items available for borrowing with details, photos, categories, and availability information, making it easy for borrowers to discover what they need.\
**principle**: If a user lists an item with photos, category, and availability times, then other users can search for and find that item when it's available, and see all the details needed to decide if it meets their needs.\
**state**:

* a set of Items with
  * an owner User
  * a title String
  * a description String
  * a category String
  * a condition String
  * a dormVisibility String
  * a createdAt Date
  * a status of LISTED or UNLISTED or REMOVED
* a set of ItemPhotos with
  * an item Item
  * a photoUrl String
  * an order Number
* a set of AvailabilityWindows with
  * an item Item
  * a startTime DateTime
  * an endTime DateTime
  * a status of AVAILABLE or RESERVED or UNAVAILABLE

**actions**:

* `createItem (owner: User, title: String, description: String, category: String, condition: String, dormVisibility: String): (item: Item)`
  * **requires**: The owner must exist. The category must be from a predefined set. The condition must be from a predefined set (e.g., NEW, LIKE\_NEW, GOOD, FAIR, POOR). The dormVisibility must be either a specific dorm name or "ALL".
  * **effects**: Creates a new item listing with status LISTED.
* `updateItem (item: Item, title: String, description: String, category: String, condition: String): ()`
  * **requires**: The item must exist and be in LISTED status.
  * **effects**: Updates the item's details.
* `addPhoto (item: Item, photoUrl: String, order: Number): ()`
  * **requires**: The item must exist. The order must be unique for the item.
  * **effects**: Adds a photo to the item.
* `removePhoto (item: Item, photoUrl: String): ()`
  * **requires**: The photo must exist for the item.
  * **effects**: Removes the photo from the item.
* `setAvailability (item: Item, startTime: DateTime, endTime: DateTime): (window: AvailabilityWindow)`
  * **requires**: The item must exist. The startTime must be before endTime. The window must not overlap with existing AVAILABLE windows for the item.
  * **effects**: Creates a new availability window for the item.
* `markUnavailable (item: Item, window: AvailabilityWindow): ()`
  * **requires**: The window must exist and be associated with the item.
  * **effects**: Sets the window status to UNAVAILABLE.
* `unlistItem (item: Item): ()`
  * **requires**: The item must exist and be in LISTED status.
  * **effects**: Sets the item status to UNLISTED, hiding it from search but preserving the listing.
* `removeItem (item: Item): ()`
  * **requires**: The item must exist.
  * **effects**: Sets the item status to REMOVED, permanently removing it from the system.

**notes**:

* Items have three status levels: LISTED (visible), UNLISTED (hidden but recoverable), and REMOVED (permanently deleted). This supports the "trash" pattern for accidental deletions.
* Availability windows are separate entities to support complex scheduling (e.g., available Monday-Friday 2-5pm, but not Tuesday 3pm).
* Dorm visibility allows items to be shown only to users in the same dorm, supporting the "dorm-specific visibility" feature.
* Photos are stored separately to support multiple photos per item with ordering.

***

## Borrowing

**concept**: Borrowing \[User, Item]\
**purpose**: To manage the complete lifecycle of borrowing requests from initial request through pickup, use, and return, enabling structured coordination between borrowers and lenders.\
**principle**: If a borrower requests to borrow an item for a specific time window, and the lender approves, then the borrower can pick up the item at the scheduled time and location, use it, and return it at the scheduled return time, completing the borrowing transaction.\
**state**:

* a set of BorrowRequests with
  * a borrower User
  * an item Item
  * a status of PENDING or APPROVED or REJECTED or CANCELLED or PICKED\_UP or RETURNED or COMPLETED
  * a requestedStartTime DateTime
  * a requestedEndTime DateTime
  * a pickupLocation String
  * a dropoffLocation String
  * a createdAt Date
  * a approvedAt Date
  * a pickedUpAt Date
  * a returnedAt Date
  * a lenderNotes String
  * a borrowerNotes String

**actions**:

* `requestBorrow (borrower: User, item: Item, requestedStartTime: DateTime, requestedEndTime: DateTime, pickupLocation: String, dropoffLocation: String, borrowerNotes: String): (request: BorrowRequest)`
  * **requires**: The item must exist and be in LISTED status. The requestedStartTime must be in the future and before requestedEndTime. There must be an available window in ItemListing that covers the requested time range.
  * **effects**: Creates a new borrow request with status PENDING.
* `approveRequest (request: BorrowRequest, lenderNotes: String): ()`
  * **requires**: The request must be in PENDING status. The lender must be the owner of the item.
  * **effects**: Sets the request status to APPROVED and records the approval time.
* `rejectRequest (request: BorrowRequest, lenderNotes: String): ()`
  * **requires**: The request must be in PENDING status. The lender must be the owner of the item.
  * **effects**: Sets the request status to REJECTED.
* `cancelRequest (request: BorrowRequest): ()`
  * **requires**: The request must be in PENDING, APPROVED, or PICKED\_UP status.
  * **effects**: Sets the request status to CANCELLED.
* `markPickedUp (request: BorrowRequest): ()`
  * **requires**: The request must be in APPROVED status. The current time must be within a reasonable window of the requestedStartTime.
  * **effects**: Sets the request status to PICKED\_UP and records the pickup time.
* `markReturned (request: BorrowRequest): ()`
  * **requires**: The request must be in PICKED\_UP status. The current time must be within a reasonable window of the requestedEndTime.
  * **effects**: Sets the request status to RETURNED and records the return time.
* `completeRequest (request: BorrowRequest): ()`
  * **requires**: The request must be in RETURNED status.
  * **effects**: Sets the request status to COMPLETED, finalizing the transaction.

**notes**:

* The status progression is: PENDING → APPROVED → PICKED\_UP → RETURNED → COMPLETED, with REJECTED and CANCELLED as terminal states.
* Both pickup and dropoff locations are stored as strings (could be campus locations like "Building 7 lobby" or "East Campus courtyard").
* The concept doesn't enforce that availability windows are reserved when a request is approved - that coordination happens via syncs with ItemListing.
* Notes fields allow both parties to communicate details about the transaction.

***

## Reputation

**concept**: Reputation \[User, BorrowRequest]\
**purpose**: To track and display user reliability scores and reviews, enabling trust-building in the community and helping users make informed decisions about lending and borrowing.\
**principle**: If a user completes a borrowing transaction, then both the lender and borrower can leave reviews and ratings, which update their reputation scores, helping future users assess their reliability.\
**state**:

* a set of Users with
  * a lenderScore Number
  * a borrowerScore Number
  * a totalLends Number
  * a totalBorrows Number
* a set of Reviews with
  * a reviewer User
  * a reviewee User
  * a rating Number
  * a comment String
  * a type of LENDER or BORROWER
  * a transaction BorrowRequest
  * a createdAt Date
* a set of Flags with
  * a flagger User
  * a flagged User
  * a reason String
  * a status of PENDING or RESOLVED or DISMISSED
  * a createdAt Date
  * a resolvedAt Date

**actions**:

* `initializeReputation (user: User): ()`
  * **requires**: The user must not already have a reputation record.
  * **effects**: Creates a reputation record for the user with scores initialized to 0 and counts to 0.
* `submitReview (reviewer: User, reviewee: User, transaction: BorrowRequest, type: LENDER or BORROWER, rating: Number, comment: String): (review: Review)`
  * **requires**: The transaction must be in COMPLETED status. The reviewer must have been a party to the transaction. The reviewer must not have already submitted a review of this type for this transaction. The rating must be between 1 and 5.
  * **effects**: Creates a new review and triggers a reputation score update.
* `flagUser (flagger: User, flagged: User, reason: String): (flag: Flag)`
  * **requires**: The flagger and flagged must be different users. The reason must be provided.
  * **effects**: Creates a new flag with status PENDING.
* `resolveFlag (flag: Flag, resolution: String): ()`
  * **requires**: The flag must be in PENDING status. The user must have admin privileges (handled via sync/authorization).
  * **effects**: Sets the flag status to RESOLVED and records the resolution time.
* `dismissFlag (flag: Flag): ()`
  * **requires**: The flag must be in PENDING status. The user must have admin privileges.
  * **effects**: Sets the flag status to DISMISSED.
* `updateScores (user: User): ()`
  * **system**
  * **requires**: The user must have a reputation record.
  * **effects**: Recalculates the user's lenderScore and borrowerScore based on all their reviews of the respective type, using an average of ratings.

**notes**:

* Reputation scores are calculated as averages, but could be enhanced with weighted algorithms (e.g., recent reviews weighted more heavily).
* The concept maintains separate scores for lending and borrowing behavior, as these are different roles with different expectations.
* Flags allow the community to report problematic behavior, with admin resolution handled via syncs.
* The updateScores system action is triggered by syncs when new reviews are submitted.

***

## Rewards

**concept**: Rewards \[User]\
**purpose**: To incentivize lending and responsible borrowing through a point-based reward system that users can redeem for priority access and community perks.\
**principle**: If a user lends an item that is successfully returned, then they earn points, which they can later redeem for priority access to high-demand items or other community benefits.\
**state**:

* a set of Users with
  * a pointsBalance Number
* a set of Transactions with
  * a user User
  * an amount Number
  * a reason String
  * a type of EARNED or REDEEMED or TRANSFERRED
  * a createdAt Date
* a set of Redemptions with
  * a user User
  * a redemptionType String
  * a pointsCost Number
  * a status of PENDING or ACTIVE or EXPIRED
  * a createdAt Date
  * an expiresAt Date

**actions**:

* `initializeRewards (user: User): ()`
  * **requires**: The user must not already have a rewards account.
  * **effects**: Creates a rewards account for the user with balance 0.
* `awardPoints (user: User, amount: Number, reason: String): (transaction: Transaction)`
  * **requires**: The user must have a rewards account. The amount must be positive.
  * **effects**: Increases the user's points balance by the amount and creates a transaction record.
* `redeemPoints (user: User, redemptionType: String, pointsCost: Number): (redemption: Redemption)`
  * **requires**: The user must have a rewards account. The user's points balance must be at least pointsCost. The redemptionType must be from a predefined set (e.g., "PRIORITY\_ACCESS", "COMMUNITY\_PERK").
  * **effects**: Decreases the user's points balance by pointsCost, creates a redemption record, and creates a transaction record.
* `activateRedemption (redemption: Redemption): ()`
  * **requires**: The redemption must be in PENDING status.
  * **effects**: Sets the redemption status to ACTIVE.
* `expireRedemption (redemption: Redemption): ()`
  * **system**
  * **requires**: The redemption must be in ACTIVE status. The current time must be after expiresAt.
  * **effects**: Sets the redemption status to EXPIRED.

**notes**:

* Points are awarded automatically via syncs when lending transactions complete successfully.
* Redemptions are separate from transactions to track active benefits (e.g., a "priority access" redemption might be active for a week).
* The concept doesn't define what redemptions actually do - that behavior is implemented via syncs with other concepts (e.g., priority access might affect search ranking in ItemListing).
* Transfer functionality could be added later but is omitted for initial simplicity.

***

## Communication

**concept**: Communication \[User, Context]\
**purpose**: To enable direct messaging between users for coordinating pickups, resolving details, and building community connections around item sharing.\
**principle**: If a user sends a message to another user in the context of a transaction (e.g., borrowing request, item claim), then the recipient receives the message and can reply, enabling coordination without leaving the platform.\
**state**:

* a set of Conversations with
  * a participant1 User
  * a participant2 User
  * a context Context
  * a contextType String
  * a createdAt Date
  * a lastMessageAt Date
* a set of Messages with
  * a conversation Conversation
  * a sender User
  * a content String
  * a createdAt Date
  * a readAt Date

**actions**:

* `createConversation (participant1: User, participant2: User, context: Context, contextType: String): (conversation: Conversation)`
  * **requires**: The participants must be different users. The context must exist. The contextType must be from a predefined set (e.g., "BORROW\_REQUEST", "ITEM\_CLAIM", "ITEM\_CONTRIBUTION"). A conversation between these participants for this context must not already exist.
  * **effects**: Creates a new conversation.
* `sendMessage (conversation: Conversation, sender: User, content: String): (message: Message)`
  * **requires**: The conversation must exist. The sender must be a participant in the conversation.
  * **effects**: Creates a new message and updates the conversation's lastMessageAt timestamp.
* `markRead (message: Message): ()`
  * **requires**: The message must exist and not already be read.
  * **effects**: Sets the readAt timestamp for the message.

**notes**:

* Conversations are scoped to a generic Context (e.g., BorrowRequest, ItemClaim, Contribution) to keep messaging organized and relevant. The contextType field helps identify what type of entity the context refers to.
* The concept doesn't handle delivery - that's the responsibility of the Notifications concept via syncs.
* Read receipts are tracked per message to support unread message counts.
* The concept is intentionally simple - no group chats or file attachments in the initial design.

***

## Notifications

**concept**: Notifications \[User]\
**purpose**: To deliver automated reminders and alerts to users about important events like upcoming returns, new requests, and item availability, reducing coordination friction.\
**principle**: If a borrowing request is approved and the pickup time is approaching, then the borrower receives a reminder notification, helping ensure timely coordination.\
**state**:

* a set of Users with
  * an email String
  * a phoneNumber String
  * a notificationPreferences String
* a set of Notifications with
  * a recipient User
  * a type String
  * a title String
  * a content String
  * a status of PENDING or SENT or FAILED
  * a createdAt Date
  * a sentAt Date
  * a readAt Date

**actions**:

* `setNotificationPreferences (user: User, email: String, phoneNumber: String, preferences: String): ()`
  * **requires**: The user must exist.
  * **effects**: Updates the user's notification preferences and contact information.
* `createNotification (recipient: User, type: String, title: String, content: String): (notification: Notification)`
  * **requires**: The recipient must exist. The type must be from a predefined set (e.g., "PICKUP\_REMINDER", "RETURN\_REMINDER", "NEW\_REQUEST", "ITEM\_AVAILABLE").
  * **effects**: Creates a new notification with status PENDING.
* `sendNotification (notification: Notification): ()`
  * **system**
  * **requires**: The notification must be in PENDING status.
  * **effects**: Delivers the notification via the user's preferred channel (email/SMS) and sets status to SENT, recording sentAt timestamp.
* `markNotificationRead (notification: Notification): ()`
  * **requires**: The notification must exist.
  * **effects**: Sets the readAt timestamp for the notification.

**notes**:

* The concept handles both the creation of notifications and their delivery, maintaining completeness as required by concept design principles.
* Notification delivery (email/SMS) must be implemented within this concept - it cannot call out to other concepts.
* The sendNotification system action is triggered by syncs or scheduled tasks when notifications are created.
* Preferences allow users to control notification frequency and channels, though the initial implementation may support only email.

***

## ItemRequest

**concept**: ItemRequest \[User]\
**purpose**: To enable users to request items they need that aren't currently listed, allowing the community to respond by offering items or crowdsourcing contributions, particularly useful for small quantities and one-off needs.\
**principle**: If a user creates a request for a small quantity of an item (e.g., "2 oz wood glue"), then other users can see the request and either offer to provide the item from their own supply or contribute a portion, enabling community-sourced fulfillment of needs through multiple small contributions.\
**state**:

* a set of ItemRequests with
  * a requester User
  * a title String
  * a description String
  * a category String
  * a requestedQuantity String
  * a urgency String
  * a dormVisibility String
  * a status of OPEN or PARTIALLY\_FULFILLED or FULFILLED or CANCELLED or EXPIRED
  * a createdAt Date
  * a fulfilledAt Date
  * a expiresAt Date
* a set of Contributions with
  * a request ItemRequest
  * a contributor User
  * a contributedQuantity String
  * a status of PENDING or ACCEPTED or REJECTED or CANCELLED
  * a createdAt Date
  * a acceptedAt Date
  * a notes String

**actions**:

* `createRequest (requester: User, title: String, description: String, category: String, requestedQuantity: String, urgency: String, dormVisibility: String, expiresAt: DateTime): (request: ItemRequest)`
  * **requires**: The requester must exist. The category must be from a predefined set. The urgency must be from a predefined set (e.g., LOW, MEDIUM, HIGH, URGENT). The dormVisibility must be either a specific dorm name or "ALL". The expiresAt must be in the future.
  * **effects**: Creates a new item request with status OPEN.
* `offerContribution (request: ItemRequest, contributor: User, contributedQuantity: String, notes: String): (contribution: Contribution)`
  * **requires**: The request must be in OPEN or PARTIALLY\_FULFILLED status. The request must not be expired. The contributor must not be the requester. The contributedQuantity must be provided.
  * **effects**: Creates a new contribution with status PENDING.
* `acceptContribution (request: ItemRequest, contribution: Contribution): ()`
  * **requires**: The contribution must be in PENDING status. The requester must be the request's requester. The request must not be FULFILLED or CANCELLED or EXPIRED.
  * **effects**: Sets the contribution status to ACCEPTED and records the acceptedAt timestamp. If the combined accepted contributions fulfill the request, sets the request status to FULFILLED and records fulfilledAt. Otherwise, sets the request status to PARTIALLY\_FULFILLED.
* `rejectContribution (request: ItemRequest, contribution: Contribution): ()`
  * **requires**: The contribution must be in PENDING status. The requester must be the request's requester.
  * **effects**: Sets the contribution status to REJECTED.
* `cancelContribution (contribution: Contribution): ()`
  * **requires**: The contribution must be in PENDING status. The contributor must be the contribution's contributor.
  * **effects**: Sets the contribution status to CANCELLED.
* `cancelRequest (request: ItemRequest): ()`
  * **requires**: The request must be in OPEN or PARTIALLY\_FULFILLED status. The requester must be the request's requester.
  * **effects**: Sets the request status to CANCELLED and cancels all pending contributions.
* `expireRequest (request: ItemRequest): ()`
  * **system**
  * **requires**: The request must be in OPEN or PARTIALLY\_FULFILLED status. The current time must be after expiresAt.
  * **effects**: Sets the request status to EXPIRED.

**notes**:

* Quantities are stored as strings (e.g., "2 oz", "3 ft") to support various units and partial quantities, which is essential for micro-requests and batch sourcing.
* Multiple contributions can be accepted for batch requests where the total needed is crowdsourced from multiple users.
* The concept tracks whether contributions fulfill the request, but actual quantity matching logic may need to be flexible (e.g., "2 oz" + "1 oz" might fulfill a "3 oz" request).
* When a contribution is accepted, syncs can trigger creation of an ItemListing entry or a Borrowing request flow.
* Urgency helps prioritize requests in search/display, especially useful for time-sensitive lab or project needs.
* Dorm visibility allows requests to be seen only by nearby students, supporting localized community sourcing.

***

## ItemTransfer

**concept**: ItemTransfer \[User, Item]\
**purpose**: To facilitate permanent transfers of items (free items, lost-and-found returns, and upcycled goods) that don't require return, reducing waste and enabling direct item redistribution within the community.\
**principle**: If a user marks an item as free or finds a lost item and posts it, then interested users can claim it for permanent transfer, completing the transaction immediately without scheduling or return logistics.\
**state**:

* a set of Items with
  * a transferType of FREE or LOST\_AND\_FOUND or UPCYCLE
  * a postedBy User
  * a title String
  * a description String
  * a category String
  * a condition String
  * a location String
  * a dormVisibility String
  * a status of AVAILABLE or PENDING or CLAIMED or EXPIRED or REMOVED
  * a postedAt Date
  * a claimedAt Date
  * a expiresAt Date
* a set of Claims with
  * an item Item
  * a claimer User
  * a status of PENDING or APPROVED or REJECTED or CANCELLED
  * a createdAt Date
  * a approvedAt Date
  * a pickupLocation String
  * a notes String

**actions**:

* `postFreeItem (postedBy: User, title: String, description: String, category: String, condition: String, location: String, dormVisibility: String, expiresAt: DateTime): (item: Item)`
  * **requires**: The postedBy must exist. The category must be from a predefined set. The condition must be from a predefined set. The dormVisibility must be either a specific dorm name or "ALL". The expiresAt must be in the future.
  * **effects**: Creates a new item with transferType FREE and status AVAILABLE.
* `postLostItem (postedBy: User, title: String, description: String, category: String, location: String, dormVisibility: String, expiresAt: DateTime): (item: Item)`
  * **requires**: The postedBy must exist. The category must be from a predefined set. The dormVisibility must be either a specific dorm name or "ALL". The expiresAt must be in the future.
  * **effects**: Creates a new item with transferType LOST\_AND\_FOUND and status AVAILABLE.
* `postUpcycleItem (postedBy: User, title: String, description: String, category: String, condition: String, location: String, dormVisibility: String, expiresAt: DateTime): (item: Item)`
  * **requires**: The postedBy must exist. The category must be from a predefined set. The condition must be from a predefined set. The dormVisibility must be either a specific dorm name or "ALL". The expiresAt must be in the future.
  * **effects**: Creates a new item with transferType UPCYCLE and status AVAILABLE.
* `claimItem (item: Item, claimer: User, pickupLocation: String, notes: String): (claim: Claim)`
  * **requires**: The item must be in AVAILABLE status and not expired. The claimer must not be the item's postedBy. The item must not already have a pending claim.
  * **effects**: Creates a new claim with status PENDING and sets the item status to PENDING.
* `approveClaim (item: Item, claim: Claim): ()`
  * **requires**: The claim must be in PENDING status. The item must be in PENDING status. The user must be the item's postedBy.
  * **effects**: Sets the claim status to APPROVED, sets the item status to CLAIMED, and records the approvedAt and claimedAt timestamps.
* `rejectClaim (item: Item, claim: Claim): ()`
  * **requires**: The claim must be in PENDING status. The item must be in PENDING status. The user must be the item's postedBy.
  * **effects**: Sets the claim status to REJECTED and sets the item status back to AVAILABLE.
* `cancelClaim (claim: Claim): ()`
  * **requires**: The claim must be in PENDING status. The user must be the claim's claimer.
  * **effects**: Sets the claim status to CANCELLED and sets the item status back to AVAILABLE.
* `completeTransfer (item: Item, claim: Claim): ()`
  * **requires**: The claim must be in APPROVED status. The item must be in CLAIMED status. Either the postedBy or claimer can complete the transfer.
  * **effects**: Marks the transfer as complete. The item can be removed from the system or archived.
* `removeItem (item: Item): ()`
  * **requires**: The item must exist. The user must be the item's postedBy.
  * **effects**: Sets the item status to REMOVED, permanently removing it from the system.
* `expireItem (item: Item): ()`
  * **system**
  * **requires**: The item must be in AVAILABLE status. The current time must be after expiresAt.
  * **effects**: Sets the item status to EXPIRED.

**notes**:

* This concept handles permanent transfers, which is fundamentally different from Borrowing (temporary loans).
* Lost-and-found items may not have condition ratings, so the postLostItem action doesn't require a condition field.
* The first-come-first-served nature means only one pending claim is allowed per item at a time.
* Once a claim is approved, the item is marked as CLAIMED, though the actual physical transfer completion is tracked separately.
* This concept supports the sustainability goal by making it easy to give away items rather than discard them.
* Syncs can connect this to rewards (e.g., points for posting free items) and notifications (e.g., alerting users about new free items in their dorm).

***
