---
timestamp: 'Tue Nov 18 2025 18:32:50 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251118_183250.8255b428.md]]'
content_id: fc154005d0794c62899eaa1e80adad13979e3fd7bad580c12cf1f8eb07e547d8
---

# Concept Specifications

## UserAuthentication

**concept**: UserAuthentication\
**purpose**: To authenticate users so that each person's data is securely associated with their identity and protected from unauthorized access.\
**principle**: If a user registers with a username and password, then later logs in using those same credentials, the system recognizes them as the same user, enabling access to their data. If they log out, their session ends and their private data becomes inaccessible until they log in again.\
**state**:

* a set of Users with
  * a username String
  * a hashedPassword String
  * an email String
  * a createdAt Date
* a set of Sessions with
  * a user User
  * a refreshToken String
  * a createdAt Date
  * an expiresAt Date

**actions**:

* `register (username: String, password: String, email: String): (user: User, accessToken: String, refreshToken: String)`
  * **requires**: The provided email and username must not already exist. The email must be in valid format.
  * **effects**: Creates a new user record with a hashed password and returns a new pair of session tokens.
* `login (username: String, password: String): (accessToken: String, refreshToken: String)`
  * **requires**: The provided username and password must match an existing user account.
  * **effects**: Creates a new session and returns a new pair of access and refresh tokens for the authenticated user.
* `logout (refreshToken: String)`
  * **requires**: A valid refresh token must be provided.
  * **effects**: Invalidates the user's current refresh token, ending their session.
* `changePassword (accessToken: String, oldPassword: String, newPassword: String)`
  * **requires**: A valid access token must be provided. The old password must match the user's current password.
  * **effects**: Updates the user's stored password hash to the new password.
* `deleteAccount (accessToken: String, password: String)`
  * **requires**: A valid access token must be provided. The provided password matches the user's current password.
  * **effects**: Permanently removes the user's account and all associated sessions.

**notes**:

* Sessions are stored separately from users to support multiple concurrent sessions per user and proper token management.
* Access tokens are not stored in state as they are stateless JWTs validated by signature. Only refresh tokens are stored for revocation purposes.
* Email is required for account recovery and notifications, though the notification delivery itself is handled by the Notifications concept.

***

## UserProfile

**concept**: UserProfile \[User]\
**purpose**: To maintain user profile information including display name, dorm affiliation, and other public-facing details that enable community connection and item discovery.\
**principle**: If a user creates a profile with their dorm and display name, then other users can find them by dorm and see their display name when viewing items they list or when communicating with them.\
**state**:

* a set of Users with
  * a displayName String
  * a dorm String
  * a bio String
  * a createdAt Date

**actions**:

* `createProfile (user: User, displayName: String, dorm: String): (profile: User)`
  * **requires**: The user must not already have a profile. The dorm must be a valid MIT dorm name.
  * **effects**: Creates a profile for the user with the provided display name and dorm.
* `updateProfile (user: User, displayName: String, dorm: String, bio: String)`
  * **requires**: The user must have an existing profile.
  * **effects**: Updates the user's profile information.
* `getProfile (user: User): (displayName: String, dorm: String, bio: String)`
  * **requires**: The user must have a profile.
  * **effects**: Returns the user's profile information.

**notes**:

* User is a generic type parameter since users are created by UserAuthentication. This concept only adds profile information to existing users.
* Dorm information is critical for the "dorm-specific visibility" feature and proximity-based recommendations.
* Display name is separate from username to allow users to present themselves differently in the community.

***

## ItemListing

**concept**: ItemListing \[User]\
**purpose**: To enable users to list items available for borrowing with details, photos, categories, and availability information, making it easy for borrowers to discover what they need.\
**principle**: If a user lists an item with photos, category, and availability times, then other users can search for and find that item when it's available, and see all the details needed to decide if it meets their needs.\
**state**:

* a set of Items with
  * an owner User
  * a title String
  * a description String
  * a category String
  * a condition String
  * a dormVisibility String
  * a createdAt Date
  * a status of LISTED or UNLISTED or REMOVED
* a set of ItemPhotos with
  * an item Item
  * a photoUrl String
  * an order Number
* a set of AvailabilityWindows with
  * an item Item
  * a startTime DateTime
  * an endTime DateTime
  * a status of AVAILABLE or RESERVED or UNAVAILABLE

**actions**:

* `createItem (owner: User, title: String, description: String, category: String, condition: String, dormVisibility: String): (item: Item)`
  * **requires**: The owner must exist. The category must be from a predefined set. The condition must be from a predefined set (e.g., NEW, LIKE\_NEW, GOOD, FAIR, POOR). The dormVisibility must be either a specific dorm name or "ALL".
  * **effects**: Creates a new item listing with status LISTED.
* `updateItem (item: Item, title: String, description: String, category: String, condition: String): ()`
  * **requires**: The item must exist and be in LISTED status.
  * **effects**: Updates the item's details.
* `addPhoto (item: Item, photoUrl: String, order: Number): ()`
  * **requires**: The item must exist. The order must be unique for the item.
  * **effects**: Adds a photo to the item.
* `removePhoto (item: Item, photoUrl: String): ()`
  * **requires**: The photo must exist for the item.
  * **effects**: Removes the photo from the item.
* `setAvailability (item: Item, startTime: DateTime, endTime: DateTime): (window: AvailabilityWindow)`
  * **requires**: The item must exist. The startTime must be before endTime. The window must not overlap with existing AVAILABLE windows for the item.
  * **effects**: Creates a new availability window for the item.
* `markUnavailable (item: Item, window: AvailabilityWindow): ()`
  * **requires**: The window must exist and be associated with the item.
  * **effects**: Sets the window status to UNAVAILABLE.
* `unlistItem (item: Item): ()`
  * **requires**: The item must exist and be in LISTED status.
  * **effects**: Sets the item status to UNLISTED, hiding it from search but preserving the listing.
* `removeItem (item: Item): ()`
  * **requires**: The item must exist.
  * **effects**: Sets the item status to REMOVED, permanently removing it from the system.

**notes**:

* Items have three status levels: LISTED (visible), UNLISTED (hidden but recoverable), and REMOVED (permanently deleted). This supports the "trash" pattern for accidental deletions.
* Availability windows are separate entities to support complex scheduling (e.g., available Monday-Friday 2-5pm, but not Tuesday 3pm).
* Dorm visibility allows items to be shown only to users in the same dorm, supporting the "dorm-specific visibility" feature.
* Photos are stored separately to support multiple photos per item with ordering.

***

## Borrowing

**concept**: Borrowing \[User, Item]\
**purpose**: To manage the complete lifecycle of borrowing requests from initial request through pickup, use, and return, enabling structured coordination between borrowers and lenders.\
**principle**: If a borrower requests to borrow an item for a specific time window, and the lender approves, then the borrower can pick up the item at the scheduled time and location, use it, and return it at the scheduled return time, completing the borrowing transaction.\
**state**:

* a set of BorrowRequests with
  * a borrower User
  * an item Item
  * a status of PENDING or APPROVED or REJECTED or CANCELLED or PICKED\_UP or RETURNED or COMPLETED
  * a requestedStartTime DateTime
  * a requestedEndTime DateTime
  * a pickupLocation String
  * a dropoffLocation String
  * a createdAt Date
  * a approvedAt Date
  * a pickedUpAt Date
  * a returnedAt Date
  * a lenderNotes String
  * a borrowerNotes String

**actions**:

* `requestBorrow (borrower: User, item: Item, requestedStartTime: DateTime, requestedEndTime: DateTime, pickupLocation: String, dropoffLocation: String, borrowerNotes: String): (request: BorrowRequest)`
  * **requires**: The item must exist and be in LISTED status. The requestedStartTime must be in the future and before requestedEndTime. There must be an available window in ItemListing that covers the requested time range.
  * **effects**: Creates a new borrow request with status PENDING.
* `approveRequest (request: BorrowRequest, lenderNotes: String): ()`
  * **requires**: The request must be in PENDING status. The lender must be the owner of the item.
  * **effects**: Sets the request status to APPROVED and records the approval time.
* `rejectRequest (request: BorrowRequest, lenderNotes: String): ()`
  * **requires**: The request must be in PENDING status. The lender must be the owner of the item.
  * **effects**: Sets the request status to REJECTED.
* `cancelRequest (request: BorrowRequest): ()`
  * **requires**: The request must be in PENDING, APPROVED, or PICKED\_UP status.
  * **effects**: Sets the request status to CANCELLED.
* `markPickedUp (request: BorrowRequest): ()`
  * **requires**: The request must be in APPROVED status. The current time must be within a reasonable window of the requestedStartTime.
  * **effects**: Sets the request status to PICKED\_UP and records the pickup time.
* `markReturned (request: BorrowRequest): ()`
  * **requires**: The request must be in PICKED\_UP status. The current time must be within a reasonable window of the requestedEndTime.
  * **effects**: Sets the request status to RETURNED and records the return time.
* `completeRequest (request: BorrowRequest): ()`
  * **requires**: The request must be in RETURNED status.
  * **effects**: Sets the request status to COMPLETED, finalizing the transaction.

**notes**:

* The status progression is: PENDING → APPROVED → PICKED\_UP → RETURNED → COMPLETED, with REJECTED and CANCELLED as terminal states.
* Both pickup and dropoff locations are stored as strings (could be campus locations like "Building 7 lobby" or "East Campus courtyard").
* The concept doesn't enforce that availability windows are reserved when a request is approved - that coordination happens via syncs with ItemListing.
* Notes fields allow both parties to communicate details about the transaction.

***

## Reputation

**concept**: Reputation \[User, BorrowRequest]\
**purpose**: To track and display user reliability scores and reviews, enabling trust-building in the community and helping users make informed decisions about lending and borrowing.\
**principle**: If a user completes a borrowing transaction, then both the lender and borrower can leave reviews and ratings, which update their reputation scores, helping future users assess their reliability.\
**state**:

* a set of Users with
  * a lenderScore Number
  * a borrowerScore Number
  * a totalLends Number
  * a totalBorrows Number
* a set of Reviews with
  * a reviewer User
  * a reviewee User
  * a rating Number
  * a comment String
  * a type of LENDER or BORROWER
  * a transaction BorrowRequest
  * a createdAt Date
* a set of Flags with
  * a flagger User
  * a flagged User
  * a reason String
  * a status of PENDING or RESOLVED or DISMISSED
  * a createdAt Date
  * a resolvedAt Date

**actions**:

* `initializeReputation (user: User): ()`
  * **requires**: The user must not already have a reputation record.
  * **effects**: Creates a reputation record for the user with scores initialized to 0 and counts to 0.
* `submitReview (reviewer: User, reviewee: User, transaction: BorrowRequest, type: LENDER or BORROWER, rating: Number, comment: String): (review: Review)`
  * **requires**: The transaction must be in COMPLETED status. The reviewer must have been a party to the transaction. The reviewer must not have already submitted a review of this type for this transaction. The rating must be between 1 and 5.
  * **effects**: Creates a new review and triggers a reputation score update.
* `flagUser (flagger: User, flagged: User, reason: String): (flag: Flag)`
  * **requires**: The flagger and flagged must be different users. The reason must be provided.
  * **effects**: Creates a new flag with status PENDING.
* `resolveFlag (flag: Flag, resolution: String): ()`
  * **requires**: The flag must be in PENDING status. The user must have admin privileges (handled via sync/authorization).
  * **effects**: Sets the flag status to RESOLVED and records the resolution time.
* `dismissFlag (flag: Flag): ()`
  * **requires**: The flag must be in PENDING status. The user must have admin privileges.
  * **effects**: Sets the flag status to DISMISSED.
* `updateScores (user: User): ()`
  * **system**
  * **requires**: The user must have a reputation record.
  * **effects**: Recalculates the user's lenderScore and borrowerScore based on all their reviews of the respective type, using an average of ratings.

**notes**:

* Reputation scores are calculated as averages, but could be enhanced with weighted algorithms (e.g., recent reviews weighted more heavily).
* The concept maintains separate scores for lending and borrowing behavior, as these are different roles with different expectations.
* Flags allow the community to report problematic behavior, with admin resolution handled via syncs.
* The updateScores system action is triggered by syncs when new reviews are submitted.

***

## Rewards

**concept**: Rewards \[User]\
**purpose**: To incentivize lending and responsible borrowing through a point-based reward system that users can redeem for priority access and community perks.\
**principle**: If a user lends an item that is successfully returned, then they earn points, which they can later redeem for priority access to high-demand items or other community benefits.\
**state**:

* a set of Users with
  * a pointsBalance Number
* a set of Transactions with
  * a user User
  * an amount Number
  * a reason String
  * a type of EARNED or REDEEMED or TRANSFERRED
  * a createdAt Date
* a set of Redemptions with
  * a user User
  * a redemptionType String
  * a pointsCost Number
  * a status of PENDING or ACTIVE or EXPIRED
  * a createdAt Date
  * an expiresAt Date

**actions**:

* `initializeRewards (user: User): ()`
  * **requires**: The user must not already have a rewards account.
  * **effects**: Creates a rewards account for the user with balance 0.
* `awardPoints (user: User, amount: Number, reason: String): (transaction: Transaction)`
  * **requires**: The user must have a rewards account. The amount must be positive.
  * **effects**: Increases the user's points balance by the amount and creates a transaction record.
* `redeemPoints (user: User, redemptionType: String, pointsCost: Number): (redemption: Redemption)`
  * **requires**: The user must have a rewards account. The user's points balance must be at least pointsCost. The redemptionType must be from a predefined set (e.g., "PRIORITY\_ACCESS", "COMMUNITY\_PERK").
  * **effects**: Decreases the user's points balance by pointsCost, creates a redemption record, and creates a transaction record.
* `activateRedemption (redemption: Redemption): ()`
  * **requires**: The redemption must be in PENDING status.
  * **effects**: Sets the redemption status to ACTIVE.
* `expireRedemption (redemption: Redemption): ()`
  * **system**
  * **requires**: The redemption must be in ACTIVE status. The current time must be after expiresAt.
  * **effects**: Sets the redemption status to EXPIRED.

**notes**:

* Points are awarded automatically via syncs when lending transactions complete successfully.
* Redemptions are separate from transactions to track active benefits (e.g., a "priority access" redemption might be active for a week).
* The concept doesn't define what redemptions actually do - that behavior is implemented via syncs with other concepts (e.g., priority access might affect search ranking in ItemListing).
* Transfer functionality could be added later but is omitted for initial simplicity.

***

## Communication

**concept**: Communication \[User, BorrowRequest]\
**purpose**: To enable direct messaging between users for coordinating pickups, resolving details, and building community connections around item sharing.\
**principle**: If a user sends a message to another user in the context of a borrowing request, then the recipient receives the message and can reply, enabling coordination without leaving the platform.\
**state**:

* a set of Conversations with
  * a participant1 User
  * a participant2 User
  * a context BorrowRequest
  * a createdAt Date
  * a lastMessageAt Date
* a set of Messages with
  * a conversation Conversation
  * a sender User
  * a content String
  * a createdAt Date
  * a readAt Date

**actions**:

* `createConversation (participant1: User, participant2: User, context: BorrowRequest): (conversation: Conversation)`
  * **requires**: The participants must be different users. The context must exist. A conversation between these participants for this context must not already exist.
  * **effects**: Creates a new conversation.
* `sendMessage (conversation: Conversation, sender: User, content: String): (message: Message)`
  * **requires**: The conversation must exist. The sender must be a participant in the conversation.
  * **effects**: Creates a new message and updates the conversation's lastMessageAt timestamp.
* `markRead (message: Message): ()`
  * **requires**: The message must exist and not already be read.
  * **effects**: Sets the readAt timestamp for the message.

**notes**:

* Conversations are scoped to a BorrowRequest context to keep messaging organized and relevant. BorrowRequest is a generic type parameter since it's created by the Borrowing concept.
* The concept doesn't handle delivery - that's the responsibility of the Notifications concept via syncs.
* Read receipts are tracked per message to support unread message counts.
* The concept is intentionally simple - no group chats or file attachments in the initial design.

***

## Notifications

**concept**: Notifications \[User]\
**purpose**: To deliver automated reminders and alerts to users about important events like upcoming returns, new requests, and item availability, reducing coordination friction.\
**principle**: If a borrowing request is approved and the pickup time is approaching, then the borrower receives a reminder notification, helping ensure timely coordination.\
**state**:

* a set of Users with
  * an email String
  * a phoneNumber String
  * a notificationPreferences String
* a set of Notifications with
  * a recipient User
  * a type String
  * a title String
  * a content String
  * a status of PENDING or SENT or FAILED
  * a createdAt Date
  * a sentAt Date
  * a readAt Date

**actions**:

* `setNotificationPreferences (user: User, email: String, phoneNumber: String, preferences: String): ()`
  * **requires**: The user must exist.
  * **effects**: Updates the user's notification preferences and contact information.
* `createNotification (recipient: User, type: String, title: String, content: String): (notification: Notification)`
  * **requires**: The recipient must exist. The type must be from a predefined set (e.g., "PICKUP\_REMINDER", "RETURN\_REMINDER", "NEW\_REQUEST", "ITEM\_AVAILABLE").
  * **effects**: Creates a new notification with status PENDING.
* `sendNotification (notification: Notification): ()`
  * **system**
  * **requires**: The notification must be in PENDING status.
  * **effects**: Delivers the notification via the user's preferred channel (email/SMS) and sets status to SENT, recording sentAt timestamp.
* `markNotificationRead (notification: Notification): ()`
  * **requires**: The notification must exist.
  * **effects**: Sets the readAt timestamp for the notification.

**notes**:

* The concept handles both the creation of notifications and their delivery, maintaining completeness as required by concept design principles.
* Notification delivery (email/SMS) must be implemented within this concept - it cannot call out to other concepts.
* The sendNotification system action is triggered by syncs or scheduled tasks when notifications are created.
* Preferences allow users to control notification frequency and channels, though the initial implementation may support only email.

***
