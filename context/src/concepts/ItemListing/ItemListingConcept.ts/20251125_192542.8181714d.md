---
timestamp: 'Tue Nov 25 2025 19:25:42 GMT-0500 (Eastern Standard Time)'
content_id: 8181714dde9e734d4a44e6fa350e4e71f800ab41485a8e60e7103a2cfb4759b8
---

# file: src\concepts\ItemListing\ItemListingConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Collection prefix to prevent collisions
const PREFIX = "ItemListing" + ".";

// Generic types used by this concept
type Item = ID;
type AvailabilityWindow = ID;

// Enumerated types
type ListingType = "BORROW" | "TRANSFER";
type ListingStatus = "AVAILABLE" | "PENDING" | "CLAIMED" | "EXPIRED";
type WindowStatus = "AVAILABLE" | "RESERVED";

/**
 * a set of Listings with
 *   an item Item
 *   a type of BORROW or TRANSFER
 *   a status of AVAILABLE or PENDING or CLAIMED or EXPIRED
 *   a dormVisibility String
 */
export interface Listing {
  _id: Item;
  type: ListingType;
  status: ListingStatus;
  dormVisibility: string;
}

/**
 * a set of ItemPhotos with
 *   an item Item
 *   a photoUrl String
 *   an order Number
 */
export interface ItemPhoto {
  _id: ID;
  item: Item;
  photoUrl: string;
  order: number;
}

/**
 * a set of AvailabilityWindows with
 *   an item Item
 *   a startTime DateTime
 *   an endTime DateTime
 *   a status of AVAILABLE or RESERVED
 */
export interface Availability {
  _id: AvailabilityWindow;
  item: Item;
  startTime: Date;
  endTime: Date;
  status: WindowStatus;
}

/**
 * @purpose To manage the public catalog of items available for borrowing or permanent transfer,
 * including their availability, photos, and visibility rules.
 */
export default class ItemListingConcept {
  listings: Collection<Listing>;
  itemPhotos: Collection<ItemPhoto>;
  availabilityWindows: Collection<Availability>;

  constructor(private readonly db: Db) {
    this.listings = this.db.collection(PREFIX + "listings");
    this.itemPhotos = this.db.collection(PREFIX + "itemPhotos");
    this.availabilityWindows = this.db.collection(PREFIX + "availabilityWindows");
  }

  /**
   * listItem (item: Item, type: BORROW or TRANSFER, dormVisibility: String): ()
   *
   * **requires**: The item must not already be listed.
   * **effects**: Makes an item visible in the catalog with status AVAILABLE.
   */
  async listItem({ item, type, dormVisibility }: { item: Item; type: ListingType; dormVisibility: string }): Promise<Empty | { error: string }> {
    const existing = await this.listings.findOne({ _id: item });
    if (existing) {
      return { error: `Item ${item} is already listed.` };
    }

    await this.listings.insertOne({
      _id: item,
      type,
      dormVisibility,
      status: "AVAILABLE",
    });

    return {};
  }

  /**
   * unlistItem (item: Item): ()
   *
   * **requires**: The item must be listed.
   * **effects**: Removes an item from the catalog, setting its status to EXPIRED.
   */
  async unlistItem({ item }: { item: Item }): Promise<Empty | { error: string }> {
    const result = await this.listings.updateOne({ _id: item }, { $set: { status: "EXPIRED" } });
    if (result.matchedCount === 0) {
      return { error: `Item ${item} is not listed.` };
    }
    return {};
  }

  /**
   * updateListingDetails(item: Item, dormVisibility: String, type: BORROW or TRANSFER): ()
   *
   * **requires**: The `item` must be listed.
   * **effects**: Updates the `dormVisibility` and `type` fields for the item's listing.
   */
  async updateListingDetails({ item, dormVisibility, type }: { item: Item; dormVisibility: string; type: ListingType }): Promise<Empty | { error: string }> {
    const result = await this.listings.updateOne({ _id: item }, { $set: { dormVisibility, type } });
    if (result.matchedCount === 0) {
      return { error: `Item ${item} is not listed.` };
    }
    return {};
  }

  /**
   * addPhoto (item: Item, photoUrl: String, order: Number): ()
   *
   * **requires**: A listing for the item must exist.
   * **effects**: Adds a photo to the item.
   */
  async addPhoto({ item, photoUrl, order }: { item: Item; photoUrl: string; order: number }): Promise<Empty | { error: string }> {
    const listing = await this.listings.findOne({ _id: item });
    if (!listing) {
      return { error: `Cannot add photo to non-existent listing for item ${item}.` };
    }

    await this.itemPhotos.insertOne({
      _id: freshID(),
      item,
      photoUrl,
      order,
    });
    return {};
  }

  /**
   * removePhoto(item: Item, photoUrl: String): ()
   *
   * **requires**: An `ItemPhoto` record must exist for the given `item` and `photoUrl`.
   * **effects**: Removes the `ItemPhoto` record.
   */
  async removePhoto({ item, photoUrl }: { item: Item; photoUrl: string }): Promise<Empty | { error: string }> {
    const result = await this.itemPhotos.deleteOne({ item, photoUrl });
    if (result.deletedCount === 0) {
      return { error: `Photo with URL ${photoUrl} for item ${item} not found.` };
    }
    return {};
  }

  /**
   * setAvailability (item: Item, startTime: DateTime, endTime: DateTime): (window: AvailabilityWindow)
   *
   * **requires**: The item must be listed with type BORROW. The window must not overlap with existing windows.
   * **effects**: Creates a new availability window for a borrowable item.
   */
  async setAvailability({ item, startTime, endTime }: { item: Item; startTime: Date; endTime: Date }): Promise<{ window: AvailabilityWindow } | { error: string }> {
    const listing = await this.listings.findOne({ _id: item });
    if (!listing) {
      return { error: `Item ${item} is not listed.` };
    }
    if (listing.type !== "BORROW") {
      return { error: `Item ${item} is for TRANSFER, not BORROW.` };
    }
    if (startTime >= endTime) {
      return { error: `Start time must be before end time.` };
    }

    // Check for overlaps
    const overlap = await this.availabilityWindows.findOne({
      item,
      startTime: { $lt: endTime },
      endTime: { $gt: startTime },
    });

    if (overlap) {
      return { error: `Availability window overlaps with an existing window.` };
    }

    const windowId = freshID() as AvailabilityWindow;
    await this.availabilityWindows.insertOne({
      _id: windowId,
      item,
      startTime,
      endTime,
      status: "AVAILABLE",
    });

    return { window: windowId };
  }

  /**
   * updateListingStatus (item: Item, status: AVAILABLE or PENDING or CLAIMED): ()
   *
   * **requires**: The item must be listed.
   * **effects**: Updates the status of the listing.
   */
  async updateListingStatus({ item, status }: { item: Item; status: "AVAILABLE" | "PENDING" | "CLAIMED" }): Promise<Empty | { error: string }> {
    const result = await this.listings.updateOne({ _id: item }, { $set: { status } });
    if (result.matchedCount === 0) {
      return { error: `Item ${item} is not listed.` };
    }
    return {};
  }

  /**
   * reserveWindow (window: AvailabilityWindow): ()
   *
   * **requires**: The window must have status AVAILABLE.
   * **effects**: Sets the window status to RESERVED.
   */
  async reserveWindow({ window }: { window: AvailabilityWindow }): Promise<Empty | { error: string }> {
    const result = await this.availabilityWindows.findOneAndUpdate({ _id: window, status: "AVAILABLE" }, { $set: { status: "RESERVED" } });

    if (!result) {
      const exists = await this.availabilityWindows.findOne({ _id: window });
      if (!exists) return { error: `Window ${window} does not exist.` };
      return { error: `Window ${window} is not available for reservation.` };
    }

    return {};
  }

  /**
   * removeAvailability(window: AvailabilityWindow): ()
   *
   * **requires**: The `window` must exist and its status must not be `RESERVED`.
   * **effects**: Removes the `AvailabilityWindow` record.
   */
  async removeAvailability({ window }: { window: AvailabilityWindow }): Promise<Empty | { error: string }> {
    const existingWindow = await this.availabilityWindows.findOne({ _id: window });
    if (!existingWindow) {
      return { error: `Window ${window} does not exist.` };
    }
    if (existingWindow.status === "RESERVED") {
      return { error: `Cannot remove a reserved window.` };
    }

    await this.availabilityWindows.deleteOne({ _id: window });
    return {};
  }

  // QUERIES
  // Note: All queries return an array, even if a single result is expected.

  /**
   * _getListingByItem(item: Item): (listing: Listing)
   * **effects**: Returns the listing details for a specific item.
   */
  async _getListingByItem({ item }: { item: Item }): Promise<Listing[]> {
    return await this.listings.find({ _id: item }).toArray();
  }

  /**
   * _getPhotosByItem(item: Item): (photo: ItemPhoto)
   * **effects**: Returns all photos for an item, sorted by order.
   */
  async _getPhotosByItem({ item }: { item: Item }): Promise<ItemPhoto[]> {
    return await this.itemPhotos.find({ item }).sort({ order: 1 }).toArray();
  }

  /**
   * _getAvailabilityByItem(item: Item): (window: AvailabilityWindow)
   * **effects**: Returns all availability windows for an item, sorted by start time.
   */
  async _getAvailabilityByItem({ item }: { item: Item }): Promise<Availability[]> {
    return await this.availabilityWindows.find({ item }).sort({ startTime: 1 }).toArray();
  }

  /**
   * _getWindow(window: AvailabilityWindow): (window: AvailabilityWindow)
   * **effects**: Returns a specific availability window by its ID.
   */
  async _getWindow({ window }: { window: AvailabilityWindow }): Promise<Availability[]> {
    return await this.availabilityWindows.find({ _id: window }).toArray();
  }

  /**
   * _getListings(type?: BORROW or TRANSFER, status?: AVAILABLE | PENDING | CLAIMED, dormVisibility?: String): (listing: Listing)
   * **effects**: Returns all listings that match the optional filter criteria.
   */
  async _getListings(
    { type, status, dormVisibility }: { type?: ListingType; status?: ListingStatus; dormVisibility?: string },
  ): Promise<Listing[]> {
    const filter: Partial<Listing> = {};
    if (type) filter.type = type;
    if (status) filter.status = status;
    if (dormVisibility) filter.dormVisibility = dormVisibility;
    return await this.listings.find(filter).toArray();
  }
}
```
